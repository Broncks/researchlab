import numpy as np
from warehouse import RMFS
import random
from math import exp
import collections
import local_alns
import multiprocessing as mp
import time


def updatePheromones (pheromoneTable, solutionList, evaporationFactor, bestAntCost, bestCost):
    """
    This Method updates the pheromone table according to a solutionlist which was generated by an ant.

    args:       pheromoneTable:                 matrix of pheromones indicating future ants the best solution
                solutionList:                   solution of best ant, which will serve as foundation for the update
                evaporationFactor:              adjusts the intensity of the regular pheromone evaporation
                bestAntCost:                    cost of the bests ant solution from this iteration
                bestCost:                       cost of the all time best solution

    return:     pheromoneTable:                 updated pheromone matrix

    """

    pheromoneTable = pheromoneTable * (1-evaporationFactor)
    costDelta = bestCost - bestAntCost

    i=0
    for eachline in solutionList:
        eachPheromoneLineUpdate1 = time.time()
        if costDelta > 0:
            pheromoneTable[i][eachline] += ((bestCost / bestAntCost)**2) * 1000
        i += 1

    return pheromoneTable


def getProbabilityForLineInPheromoneTable (lineInPheromoneTable, sortedPodProbability, returningPodID, heuristicParameter):
    """
    This Method takes the vectors from each line of the pheromone matrix and turns it into probabilities. 
    There is also an implementation of a heuristic in this methods which influences the probability output 

    args:       lineInPheromoneTable:                   line from pheromone table which can be seen as a vector, showing the pheromone concentration of each possible solution (for this returning pod)
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
                returningPodID:                         id of returning pod for this line
                heuristicParameter:                     determines the weight of the heuristic influence
    returns:    probabilityFromlineInPheromoneTable     probability for each returning place from pheromones and heuristic (for this returning pod)
    """

    if max(lineInPheromoneTable) > sum(lineInPheromoneTable)*3 - max(lineInPheromoneTable):
        heuristicParameter = 1.0

    if returningPodID != -1:
        podProbabilityIndex = list(sortedPodProbability.keys()).index(returningPodID)

        if podProbabilityIndex/len(sortedPodProbability) > 0.66:
            #pod relevance level 1
            lineInPheromoneTable[0] = lineInPheromoneTable[0] * heuristicParameter
        elif podProbabilityIndex/len(sortedPodProbability) > 0.33:
            #pod relevance level 2
            lineInPheromoneTable[1] = lineInPheromoneTable[1] * heuristicParameter
        elif podProbabilityIndex/len(sortedPodProbability) > 0.15:
            #pod relevance level 3
            lineInPheromoneTable[2] = lineInPheromoneTable[2] * heuristicParameter
        else:
            #podRelevanceLevel 4
            lineInPheromoneTable[3] = lineInPheromoneTable[3] * heuristicParameter

    probabilityFromlineInPheromoneTable = lineInPheromoneTable/sum(lineInPheromoneTable)

    return probabilityFromlineInPheromoneTable


def createSolution (pheromoneTable, max_placeid, returningPods, sortedPodProbability, heuristicParamater):
    """
    This Methods creates a usable solution using the pheromone matrix and the heuristics

    args:       pheromoneTable:                         matrix of pheromones indicating future ants the best solution
                max_placeid:                            maximum returning destination for the pods
                returningPods:                          list of returning pods which have to be stored
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
                heuristicParamater:                     determines the weight of the heuristic influence
    returns:    returnSolution:                         viable solutionlist which can be given to the warehouse module
    """

    returnSolution = []
    solutionLine = np.arange(max_placeid)
    lineNumber = 0

    for eachline in pheromoneTable:
        probability = getProbabilityForLineInPheromoneTable(eachline, sortedPodProbability, returningPods[lineNumber], heuristicParamater)
        returnSolution.append(np.random.choice(solutionLine, p = probability))
        lineNumber += 1

    return returnSolution


def getPodProbability(returningPods):
    """
    this method creates a sorted dictionary which includes the probability for each returning pod

    args:       returningPods:                          list of returning pods which have to be stored
    returns:    sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
    """

    appearanceCounter = {}
    for podId in range(max(returningPods+1)):
        appearanceCounter.update({podId:0})
    for eachpod in returningPods:
        if eachpod != -1:
            appearanceCounter[eachpod] = appearanceCounter[eachpod]+1
    appearanceCounterSum = sum(appearanceCounter.values())
    for eachDictionaryKey in appearanceCounter:
        appearanceCounter[eachDictionaryKey] = appearanceCounter[eachDictionaryKey]/appearanceCounterSum
    sortedProbabilities = collections.OrderedDict(sorted(appearanceCounter.items(), key=lambda t: t[1]))

    return sortedProbabilities

def acoSolve(rmfs, demandlist, initsol, returningPods, antPopulation, maxIterationCount, evaporationFactor):
    """
    This Methods runs the ant colonization sequentially to create a solution for returning pods which can be given to the warehouse module

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                demandlist:                             list of demand for the warehouse
                initsol:                                initial solution to determine starting parameters
                returningPods:                          list of returning pods which have to be stored
                antPopulation:                          number of ants per colony
                maxIterationCount:                      maximum number of iterations for aco
                evaporationFactor:                      adjusts the intensity of the regular pheromone evaporation
    returns:    localSolutionlist:                      best solutionlist generated by aco which can be given to the warehouse module (further improved by local_alns)
    """
    
    _ , startingCost = rmfs.run(demandlist, initsol)
    bestSolutionlist = initsol.copy()
    bestCost = startingCost
    max_placeid = 4
    pheromoneTable = np.full((len(returningPods),max_placeid),1000.0)
    sortedPodProbability = getPodProbability(returningPods)

    iterationCounter = 0
    while iterationCounter <= maxIterationCount and bestCost > 64000:
        localBestCost = startingCost
        localBestSolution = initsol

        for _ in range(antPopulation):
            currentSolution = createSolution(pheromoneTable, max_placeid, returningPods, sortedPodProbability, 1.3)
            _ , currentCost = rmfs.run(demandlist, currentSolution)

            if localBestCost > currentCost:
                localBestCost = currentCost
                localBestSolution = currentSolution.copy()
            
        costDelta = bestCost - localBestCost
        pheromoneTable = updatePheromones(pheromoneTable, localBestSolution, evaporationFactor, localBestCost, bestCost)
    
        if costDelta > 0:
            bestCost = localBestCost
            bestSolutionlist = localBestSolution.copy()

        iterationCounter += 1

    # Additional local optimization with a LNS algorithm, after the best solution for our heuristics have been reached:
    print("ACO solution (sequentially) generated - best result: " + str(bestCost))
    print("local search optimization (LNS):")
    localSolutionlist = local_alns.solve(rmfs, demandlist, bestSolutionlist, returningPods, 100)

    return localSolutionlist


def parallelSolutionGeneration(rmfs, pheromoneTable, max_placeid, returningPods, sortedPodProbability, demandlist, colonyResult):
    """
    This Methods is being called in parallel and creates a solution for the given pheromone table and calculates its cost

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                pheromoneTable:                         matrix of pheromones indicating future ants the best solution
                max_placeid:                            maximum returning destination for the pods
                returningPods:                          list of returning pods which have to be stored
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value
                demandlist:                             list of demand for the warehouse
                colonyResult:                           managed variable which includes this ant colony results
    """

    antSolution = createSolution(pheromoneTable, max_placeid, returningPods, sortedPodProbability, 30.0)
    _ , antCost  = rmfs.run(demandlist, antSolution)
    colonyResult.append((antCost,antSolution))


def solve_parallel(rmfs, demandlist, initsol, returningPods, antPopulation, maxIterationCount, evaporationFactor):
    """
    This Methods runs the ant colonization in parallel to create a solution for returning pods which can be given to the warehouse module

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                demandlist:                             list of demand for the warehouse
                initsol:                                initial solution to determine starting parameters
                returningPods:                          list of returning pods which have to be stored
                antPopulation:                          number of ants per colony
                maxIterationCount:                      maximum number of iterations for aco
                evaporationFactor:                      adjusts the intensity of the regular pheromone evaporation
    returns:    localSolutionlist:                      best solutionlist generated by aco which can be given to the warehouse module (further improved by local_alns)
    """
    
    _ , startingCost = rmfs.run(demandlist, initsol)
    bestSolutionlist = initsol.copy()
    bestCost = startingCost
    max_placeid = 4
    pheromoneTable = np.full((len(returningPods),max_placeid),1000.0)
    sortedPodProbability = getPodProbability(returningPods)

    iterationCounter = 0
    while bestCost > 64000 and iterationCounter <= maxIterationCount: #for _ in range(iterationCount):
        processes = []
        manager = mp.Manager()
        colonyResult=manager.list()

        for _ in range(antPopulation):
            p = mp.Process(target=parallelSolutionGeneration,args=(rmfs, pheromoneTable, max_placeid, returningPods, sortedPodProbability, demandlist, colonyResult))
            processes.append(p)
            p.start()

        for process in processes:
            process.join()

        bestAntCost = min(colonyResult)[0]
        bestAntSolution = min(colonyResult)[1]

        costDelta = bestCost - bestAntCost
        pheromoneTable = updatePheromones(pheromoneTable, bestAntSolution, evaporationFactor, bestAntCost, bestCost)
    
        if costDelta > 0:
            bestCost = bestAntCost
            bestSolutionlist = bestAntSolution.copy()

        iterationCounter += 1

    # Additional local optimization with a LNS algorithm, after the best solution for our heuristics have been reached:
    print("ACO solution (parallelized) generated - best result: " + str(bestCost))
    print("local search optimization (LNS):")

    localSolutionlist = local_alns.solve(rmfs, demandlist, bestSolutionlist, returningPods, 100)
        

    return localSolutionlist
