import numpy as np
from warehouse import RMFS
import random
from math import exp
import collections
import local_alns
import multiprocessing as mp
import time

# diese Methode wird von allen Methoden als letztes ausgeführt
def updatePheromones (pheromoneTable, solutionList, evaporationFactor, bestAntCost, bestCost):
    """
    This Method updates the pheromone table according to a solutionlist which was generated by an ant.

    args:       pheromoneTable:                 matrix of pheromones indicating future ants the best solution
                solutionList:                   solution of best ant, which will serve as foundation for the update
                evaporationFactor:              adjusts the intensity of the regular pheromone evaporation
                bestAntCost:                    cost of the bests ant solution from this iteration
                bestCost:                       cost of the all time best solution

    return:     pheromoneTable:                 updated pheromone matrix

    """

    pheromoneTable = pheromoneTable * (1-evaporationFactor) # Gewollte Begrenzung des Wachstums
    # multiliziert er hier jeden Wert aus der Matrix ?
    costDelta = bestCost - bestAntCost

    i=0
    for eachline in solutionList:
        eachPheromoneLineUpdate1 = time.time() # ????? Kann raus oder ?
        if costDelta > 0:
            pheromoneTable[i][eachline] += ((bestCost / bestAntCost)**2) * 1000
            # Woher kommt die Berechnung ? Warum hoch zwei und mal 1000
        i += 1 # hier werden erts alle Spalten durchgegenagen und dann die Zeilen

    return pheromoneTable


def getProbabilityForLineInPheromoneTable (lineInPheromoneTable, sortedPodProbability, returningPodID, heuristicParameter):
    """
    This Method takes the vectors from each line of the pheromone matrix and turns it into probabilities. 
    There is also an implementation of a heuristic in this methods which influences the probability output 

    args:       lineInPheromoneTable:                   line from pheromone table which can be seen as a vector, showing the pheromone concentration of each possible solution (for this returning pod)
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
                returningPodID:                         id of returning pod for this line
                heuristicParameter:                     determines the weight of the heuristic influence
    returns:    probabilityFromlineInPheromoneTable     probability for each returning place from pheromones and heuristic (for this returning pod)
    """

    if max(lineInPheromoneTable) > sum(lineInPheromoneTable)*3 - max(lineInPheromoneTable):
        heuristicParameter = 1.0

    if returningPodID != -1:
        podProbabilityIndex = list(sortedPodProbability.keys()).index(returningPodID)
        #??? was ist dieses .keys() und was ist dieses .index??
        if podProbabilityIndex/len(sortedPodProbability) > 0.66: # Zahlen willkürlich gewählt?
            #pod relevance level 1
            lineInPheromoneTable[0] = lineInPheromoneTable[0] * heuristicParameter
        elif podProbabilityIndex/len(sortedPodProbability) > 0.33:
            #pod relevance level 2
            lineInPheromoneTable[1] = lineInPheromoneTable[1] * heuristicParameter
        elif podProbabilityIndex/len(sortedPodProbability) > 0.15:
            #pod relevance level 3
            lineInPheromoneTable[2] = lineInPheromoneTable[2] * heuristicParameter
        else:
            #podRelevanceLevel 4
            lineInPheromoneTable[3] = lineInPheromoneTable[3] * heuristicParameter

    probabilityFromlineInPheromoneTable = lineInPheromoneTable/sum(lineInPheromoneTable)

    return probabilityFromlineInPheromoneTable


def createSolution (pheromoneTable, max_placeid, returningPods, sortedPodProbability, heuristicParamater):
    """
    This Methods creates a usable solution using the pheromone matrix and the heuristics

    args:       pheromoneTable:                         matrix of pheromones indicating future ants the best solution
                max_placeid:                            maximum returning destination for the pods
                returningPods:                          list of returning pods which have to be stored
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
                heuristicParamater:                     determines the weight of the heuristic influence
    returns:    returnSolution:                         viable solutionlist which can be given to the warehouse module
    """

    returnSolution = []
    solutionLine = np.arange(max_placeid) # Erstellen eines Arrays der Länge 4 mit den Werten 0-3
    # = array ([0, 1, 2, 3])
    lineNumber = 0

    for eachline in pheromoneTable:
        probability = getProbabilityForLineInPheromoneTable(eachline, sortedPodProbability, returningPods[lineNumber], heuristicParamater)
        returnSolution.append(np.random.choice(solutionLine, p = probability))
        # Aus dem vorher erstellten Array 0-3 haben jetzt alle Werte die Wahrscheinlichkeit probability
        # und einer dieser Werte wird ausgewählt
        lineNumber += 1

    return returnSolution


def getPodProbability(returningPods):
    """
    this method creates a sorted dictionary which includes the probability for each returning pod

    args:       returningPods:                          list of returning pods which have to be stored
    returns:    sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value 
    """

    appearanceCounter = {}
    for podId in range(max(returningPods+1)):
        appearanceCounter.update({podId:0})
    for eachpod in returningPods:
        if eachpod != -1:
            appearanceCounter[eachpod] = appearanceCounter[eachpod]+1
    appearanceCounterSum = sum(appearanceCounter.values())
    for eachDictionaryKey in appearanceCounter:
        appearanceCounter[eachDictionaryKey] = appearanceCounter[eachDictionaryKey]/appearanceCounterSum
    sortedProbabilities = collections.OrderedDict(sorted(appearanceCounter.items(), key=lambda t: t[1]))

    return sortedProbabilities

def acoSolve(rmfs, demandlist, initsol, returningPods, antPopulation, maxIterationCount, evaporationFactor):
    """
    This Methods runs the ant colonization sequentially to create a solution for returning pods which can be given to the warehouse module

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                demandlist:                             list of demand for the warehouse
                initsol:                                initial solution to determine starting parameters
                returningPods:                          list of returning pods which have to be stored
                antPopulation:                          number of ants per colony
                maxIterationCount:                      maximum number of iterations for aco
                evaporationFactor:                      adjusts the intensity of the regular pheromone evaporation (begrenzt das Wachstum angemessen)
    returns:    localSolutionlist:                      best solutionlist generated by aco which can be given to the warehouse module (further improved by local_alns)
    """
    
    _ , startingCost = rmfs.run(demandlist, initsol)
    bestSolutionlist = initsol.copy()
    bestCost = startingCost
    max_placeid = 4 #Warum ist die maxPlaceId =4?
    pheromoneTable = np.full((len(returningPods),max_placeid),1000.0)
    # ist das ein zweidimesionales Array mit nur den Werten 1000???
    # oder ein Array mit den Werten von x bis y?

    #Return a new array of given shape and type, filled with fill_value.
    #Parameters
    # shape: int or sequence of ints = Shape of the new array, e.g., (2, 3) or 2. = hier haben wir ersteres
    # fill_value: scalar or array_like = Fill value.

    sortedPodProbability = getPodProbability(returningPods) #Aufruf Methode
    # Brauchen wir diese Methode ? Weil verwenden können wir sie nicht, weil wir kein returning pods haben

    iterationCounter = 0
    while iterationCounter <= maxIterationCount and bestCost > 64000:
        localBestCost = startingCost
        localBestSolution = initsol

        for _ in range(antPopulation):
            currentSolution = createSolution(pheromoneTable, max_placeid, returningPods, sortedPodProbability, 1.3)
            _ , currentCost = rmfs.run(demandlist, currentSolution)

            if localBestCost > currentCost: # falls bessere Kosten gefunden wurden
                localBestCost = currentCost
                localBestSolution = currentSolution.copy()

        costDelta = bestCost - localBestCost
        pheromoneTable = updatePheromones(pheromoneTable, localBestSolution, evaporationFactor, localBestCost, bestCost)

        if costDelta > 0:
            bestCost = localBestCost        
            bestSolutionlist = localBestSolution.copy()

        iterationCounter += 1

    # Additional local optimization with a LNS algorithm, after the best solution for our heuristics have been reached:
    print("ACO solution (sequentially) generated - best result: " + str(bestCost))
    print("local search optimization (LNS):")
    localSolutionlist = local_alns.solve(rmfs, demandlist, bestSolutionlist, returningPods, 100)

    return localSolutionlist


def parallelSolutionGeneration(rmfs, pheromoneTable, max_placeid, returningPods, sortedPodProbability, demandlist, colonyResult):
    """
    This Methods is being called in parallel and creates a solution for the given pheromone table and calculates its cost

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                pheromoneTable:                         matrix of pheromones indicating future ants the best solution
                max_placeid:                            maximum returning destination for the pods
                returningPods:                          list of returning pods which have to be stored
                sortedPodProbability:                   sorted dictionary of each pod containing its probability of appearance as value
                demandlist:                             list of demand for the warehouse
                colonyResult:                           managed variable which includes this ant colony results
    """

    antSolution = createSolution(pheromoneTable, max_placeid, returningPods, sortedPodProbability, 30.0)
    _ , antCost  = rmfs.run(demandlist, antSolution)
    colonyResult.append((antCost,antSolution))


def solve_parallel(rmfs, demandlist, initsol, returningPods, antPopulation, maxIterationCount, evaporationFactor):
    """
    This Methods runs the ant colonization in parallel to create a solution for returning pods which can be given to the warehouse module

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                demandlist:                             list of demand for the warehouse
                initsol:                                initial solution to determine starting parameters
                returningPods:                          list of returning pods which have to be stored
                antPopulation:                          number of ants per colony
                maxIterationCount:                      maximum number of iterations for aco
                evaporationFactor:                      adjusts the intensity of the regular pheromone evaporation
    returns:    localSolutionlist:                      best solutionlist generated by aco which can be given to the warehouse module (further improved by local_alns)
    """
    
    _ , startingCost = rmfs.run(demandlist, initsol)
    bestSolutionlist = initsol.copy()
    bestCost = startingCost
    max_placeid = 4
    pheromoneTable = np.full((len(returningPods),max_placeid),1000.0)
    sortedPodProbability = getPodProbability(returningPods)

    iterationCounter = 0
    while bestCost > 64000 and iterationCounter <= maxIterationCount: #for _ in range(iterationCount):
        processes = []
        manager = mp.Manager()
        colonyResult=manager.list()

        for _ in range(antPopulation):
            p = mp.Process(target=parallelSolutionGeneration,args=(rmfs, pheromoneTable, max_placeid, returningPods, sortedPodProbability, demandlist, colonyResult))
            processes.append(p)
            p.start()

        for process in processes:
            process.join()

        bestAntCost = min(colonyResult)[0]
        bestAntSolution = min(colonyResult)[1]

        costDelta = bestCost - bestAntCost
        pheromoneTable = updatePheromones(pheromoneTable, bestAntSolution, evaporationFactor, bestAntCost, bestCost)
    
        if costDelta > 0:
            bestCost = bestAntCost
            bestSolutionlist = bestAntSolution.copy()

        iterationCounter += 1

    # Additional local optimization with a LNS algorithm, after the best solution for our heuristics have been reached:
    print("ACO solution (parallelized) generated - best result: " + str(bestCost))
    print("local search optimization (LNS):")

    localSolutionlist = local_alns.solve(rmfs, demandlist, bestSolutionlist, returningPods, 100)
        

    return localSolutionlist
