# pi describes a particular problem instance = Demandlist???
# tau = Pheromone concentration
# h = Heuristic function for the pheromone update
# TODO: Parallelization (one ant one thread) & Synchronization
import random
import multiprocessing as mp
import numpy as np


def aco(rmfs, demandlist, h, rand_solutionlist):
    ANT_POPULATION = 25
    MAX_ITERATIONS = 100
    EVAPORATION_FACTOR = 0.7
    MAX_PLACE = 4

    solutionlist = []
    best_solutionlist = rand_solutionlist.copy()  # Ist das wirklich eine leere Liste? Siehe Folie 14/29 Zeile 2
    pheromonelist = np.full((len(demandlist), MAX_PLACE), 1000)  # initTrails(demandlist)

    storage, cost = rmfs.run(demandlist, best_solutionlist)

    while not terminate(demandlist, solutionlist):
        solutionlist = construct(demandlist, pheromonelist, h)
        solutionlist = localSearch(demandlist, solutionlist)  # Optional, but recommended (think about your bonus points ;))))
        if best(demandlist, solutionlist) < cost(best_solutionlist):  # TODO: Implement cost calculation f(s*)
            best_solutionlist = best(demandlist, solutionlist)
        pheromonelist = updateTrails(demandlist, solutionlist, pheromonelist)


def solve_parallel(rmfs, demandlist, initsol):
    """
    This Methods runs the ant colonization in parallel to create a solution for returning pods which can be given to the warehouse module

    args:       rmfs:                                   warehouse object capable of simulating the warehouse to calculate costs for a given solution
                demandlist:                             list of demand for the warehouse
                initsol:                                initial solution to determine starting parameters
                returningPods:                          list of returning pods which have to be stored
                antPopulation:                          number of ants per colony
                maxIterationCount:                      maximum number of iterations for aco
                evaporationFactor:                      adjusts the intensity of the regular pheromone evaporation
    returns:    localSolutionlist:                      best solutionlist generated by aco which can be given to the warehouse module (further improved by local_alns)
    """

    _, startingCost = rmfs.run(demandlist, initsol)
    bestSolutionlist = initsol.copy()
    bestCost = startingCost
    max_placeid = 4
    pheromoneTable = np.full((len(returningPods), max_placeid), 1000.0)
    sortedPodProbability = getPodProbability(returningPods)

    iterationCounter = 0
    while bestCost > 64000 and iterationCounter <= maxIterationCount:  # for _ in range(iterationCount):
        processes = []
        manager = mp.Manager()
        colonyResult = manager.list()

        for _ in range(antPopulation):
            p = mp.Process(target=parallelSolutionGeneration, args=(
            rmfs, pheromoneTable, max_placeid, returningPods, sortedPodProbability, demandlist, colonyResult))
            processes.append(p)
            p.start()

        for process in processes:
            process.join()

        bestAntCost = min(colonyResult)[0]
        bestAntSolution = min(colonyResult)[1]

        costDelta = bestCost - bestAntCost
        pheromoneTable = updatePheromones(pheromoneTable, bestAntSolution, evaporationFactor, bestAntCost, bestCost)

        if costDelta > 0:
            bestCost = bestAntCost
            bestSolutionlist = bestAntSolution.copy()

        iterationCounter += 1

    # Additional local optimization with a LNS algorithm, after the best solution for our heuristics have been reached:
    print("ACO solution (parallelized) generated - best result: " + str(bestCost))
    print("local search optimization (LNS):")

    # fuck you localSolutionlist = local_alns.solve(rmfs, demandlist, bestSolutionlist, returningPods, 100)

    return localSolutionlist


def terminate(pi, s):
    return bool

def construct(pi, tau, h):
    pass

def localSearch(pi, s):
    pass

def best(pi, s):
    pass


def updateTrails(pi, solutionList, pheromonelist, evaporationFactor, bestAntCost, bestCost):  # TODO
    """
    This Method updates the pheromone table according to a solutionlist which was generated by an ant.

    args:       pheromoneTable:                 matrix of pheromones indicating future ants the best solution
                solutionList:                   solution of best ant, which will serve as foundation for the update
                evaporationFactor:              adjusts the intensity of the regular pheromone evaporation
                bestAntCost:                    cost of the bests ant solution from this iteration
                bestCost:                       cost of the all time best solution

    return:     pheromoneTable:                 updated pheromone matrix
    """

    pheromonelist = pheromonelist * (1 - evaporationFactor)
    costDelta = bestCost - bestAntCost

    i=0
    for eachline in solutionList:
        if costDelta > 0:
            pheromonelist[i][eachline] += ((bestCost / bestAntCost) ** 2) * 1000
        i += 1

    return pheromonelist


class Ant:
    def __init__(self, wl, dl):  # Konstruktor
        self.weightlist = wl
        self.demandlist = dl.copy()
        print("Ameise!")

    def createSolution(self):
        pissweg = [random.randint(0, 3) for i in range(len(self.demandlist))]
        index_destroy = np.random.choice(range(len(destroy)), p=weight_to_prob(weight_destroy))
        print("pissweg:", pissweg)
        return pissweg


class Colony:
    def __init__(self, pl, dl, ANT_AMOUNT):  # Konstruktor
        self.pheromonelist = pl
        self.ANT_AMOUNT = ANT_AMOUNT

        self.weightlist = self.weight_to_prob(self.pheromonelist)

        self.ant_list = []
        for i in range(ANT_AMOUNT):
            self.ant_list.append(Ant(self.weightlist))

    def iterate(self):
        pisswege = []
        for i in self.ant_list:
            pisswege.append(i.createSolution())

        self.pheromonelist = self.update_pheromones(pisswege)
        self.weightlist = self.weight_to_prob(self.pheromonelist)

    def weight_to_prob(self, pl):
        """
            Converts the weights to percentages

            Args:
                weight_list (list): Contains the current weights for either the repair or destroy methods

            Return:
                wl (list): Weight list with values in percent
        """
        weightlist = pl.copy()

        for i in range(len(weightlist)):
            sum = 0
            for item in weightlist[i]:
                sum += item
            for j in range(len(weightlist[i])):
                weightlist[i][j] = weightlist[i][j] / sum
        return weightlist

    def update_pheromones(self, pisswege):
        master_table = np.full((len(pisswege), MAX_PLACE), 0)
        for pw in pisswege:
            for i in range(len(pw)):
                master_table[i][pw[i]] += 1


        for i in range(len(master_table)):
            for j in range(len(master_table[i])):
                self.pheromonelist[i][j] = self.pheromonelist[i][j] * (1 - EVAPORATION_FACTOR)   +    EVAPORATION_FACTOR * master_table[i][j] * (cost(pisswege[i][j]) # SUMME ALLER KOSTEN DER LÃ–SUNGEN (f(s) IN EINEM FELD i,j) OR 0
                                                            # Abdunstung der Pheromone
                master_table[i][j] = master_table[i][j]


if __name__ == '__main__':
    c = Colony([], [], 25)
    print(c.weight_to_prob(np.full((10000, 4), 1000.0)))
    print(c.weight_to_prob([[900, 1000, 1100, 1200],[1000,1000,1000,1000],[500, 1000, 1500, 2000]]))
    """
    Colony()
    ant = Ant([])
    ant.createSolution()"""
